"use client";

import React, { useEffect, useState, useMemo, Fragment } from "react";
import { useParams } from "next/navigation";
import axios, { AxiosError } from "axios";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  ResponsiveContainer,
  TooltipProps, // Import specific TooltipProps
} from "recharts";
import { NameType, ValueType } from 'recharts/types/component/DefaultTooltipContent'; // Import specific types for Tooltip

/* ---------------------------------------------------------------- type-defs */
// Type for a single row of data (month + employee values)
// Values can be numbers (scores), null (missing data), or potentially strings if API returns them
type DataRow = Record<string, string | number | null> & { name: string };

// Interface for Sub-blocks
interface ISubBlock {
  subblockName: string;
  data: DataRow[];
}

// Interface for main Blocks
export interface IBlock {
  blockName: string;
  data: DataRow[];
  subblocks?: ISubBlock[];
  // Added for processing duplicate BLOCK names (like Report #1, Report #2)
  displayName?: string;
}

// Interface for the API response structure
interface ApiResponse {
  ReportData: IBlock[];
}

// Interface for styles generated by makeStyles
interface StyleMap {
  [key: string]: { color: string; dash: string };
}

/* --------------------------------------------------------------- constants */
const allMonths: string[] = [
  "Mar 2025", "Apr 2025", "May 2025", "Jun 2025", "Jul 2025", "Aug 2025",
  "Sep 2025", "Oct 2025", "Nov 2025", "Dec 2025", "Jan 2026", "Feb 2026",
];
const palette: string[] = [
  "#3b82f6", "#e53935", "#f59e0b", "#9333ea", "#ef4444",
  "#f97316", "#22c55e", "#eab308", "#8b5cf6", "#009688",
  "#795548", "#d81b60", "#43a047", "#5e35b1", "#039be5",
  "#ff6f00", "#607d8b", "#00897b", "#c0ca33", "#6d4c41",
];
const dashes: string[] = ["0", "3 3", "1 1", "5 2", "3 4 1 4", "3 3 1 3", "7 3 1 3", "2 2"];

/* ---------------------------------------------------------------- helpers */

// Ensures all months defined in `allMonths` are present in the data array.
const fillMonths = (data: DataRow[]): DataRow[] => {
  const map: Record<string, DataRow> = {};
  // Create a map of existing data by month name
  data.forEach(d => { if (d?.name) map[d.name] = d; });

  // Get all unique data keys (employee names, potentially with suffixes/parens)
  const keys: string[] = Array.from(
    new Set(data.flatMap(i => Object.keys(i)).filter(k => k !== "name"))
  );

  // Map over all defined months
  return allMonths.map((monthName: string): DataRow => {
    // If data exists for this month, use it
    if (map[monthName]) return map[monthName];

    // Otherwise, create a placeholder object with the month name
    // and null values for all potential data keys (important for `connectNulls`)
    const placeholder: DataRow = { name: monthName };
    keys.forEach(k => { placeholder[k] = null; });
    return placeholder;
  });
};

/**
 * Transforms raw chart data:
 * 1. Fills missing months using `fillMonths`.
 * 2. Processes each data key (employee name) within a row:
 *    - Removes trailing parenthetical content (e.g., "(Mar 2025)").
 *    - Removes trailing " #n" suffixes (e.g., " #2").
 *    - Assigns the value to the cleaned base name, effectively merging data
 *      for variations like "Sajid Hossain" and "Sajid Hossain #2".
 */
const transformChartData = (raw: DataRow[]): DataRow[] => {
  const filled: DataRow[] = fillMonths(raw); // Ensure all months are present
  return filled.map((row: DataRow): DataRow => {
    const newObj: DataRow = { name: row.name }; // Start with month name
    for (const [key, value] of Object.entries(row)) {
      if (key === "name") continue; // Skip the month name key itself

      let baseName: string = key.trim();

      // Step 1: Remove trailing parenthetical content like "(Mar 2025)"
      baseName = baseName.replace(/\s*\([^)]*\)\s*$/, "").trim();

      // Step 2: Remove trailing " #n" suffix if present
      baseName = baseName.replace(/\s+#\d+\s*$/, "").trim();

      // Assign the value to the final cleaned baseName key.
      newObj[baseName] = value;
    }
    return newObj;
  });
};


/**
 * Rounds a number according to the rule:
 * - If decimal part is > 0.5, round up (ceiling).
 * - If decimal part is <= 0.5, round down (floor/truncate).
 * - Returns non-numbers as is.
 */
const round = (v: unknown): number | unknown => {
  if (typeof v !== 'number' || isNaN(v)) {
    return v; // Return non-numbers or NaN as is
  }
  const decimalPart = v % 1;
  if (decimalPart > 0.5) {
    return Math.ceil(v);
  } else {
    return Math.floor(v);
  }
};

// Creates style mapping (color, dash) for a list of names (unified employee names)
const makeStyles = (names: string[]): StyleMap =>
  names.reduce((map, name, index) =>
    ({ ...map, [name]: { color: palette[index % palette.length], dash: dashes[index % dashes.length] } }),
    {} as StyleMap
  );

/* ------------------------------------------------------------- sub-parts */

// Use specific types from Recharts for the Tooltip payload
const CustomTooltip: React.FC<TooltipProps<ValueType, NameType>> = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
        return (
            <div className="rounded border border-gray-300 bg-white p-2 text-xs shadow">
                <p className="font-semibold mb-1">{label}</p>
                {payload.map((entry, index) => (
                    // entry.name should be the unified employee name (string)
                    // entry.value can be number | null
                    <p key={`tooltip-${index}`} style={{ color: entry.color }}>
                        {entry.name}: {typeof round(entry.value) === "number" ? round(entry.value) as number : 0}
                    </p>
                ))}
            </div>
        );
    }
    return null;
};




const StatsTable: React.FC<{ rows: DataRow[] }> = ({ rows }) => {
  if (!rows.length) return null;

  const keys = Object.keys(rows[0]);
  const data = rows.filter(r =>
    keys.some(k => k !== "name" && r[k] != null && r[k] !== "")
  );
  if (!data.length) return null;

  return (
    <div className="overflow-x-auto mt-6 print:overflow-visible">
      <table className="min-w-full border-collapse text-xs print:text-[10px]">
        <thead>
          <tr>{keys.map(k => (
            <th
              key={k}
              className="border border-gray-700 bg-gray-100 px-2 py-1 font-medium"
            >
              {k}
            </th>
          ))}</tr>
        </thead>

        <tbody>
          {data.map((row, i) => (
            <tr
              key={i}
              className={`${i % 2 ? "bg-gray-50" : ""} print:bg-white`}
            >{keys.map(k => (
              <td
                key={k}
                className="border border-gray-700 px-2 py-1 text-center"
              >
                {k === "name" ? String(row[k] ?? "") : String(round(row[k]) ?? "")}
              </td>
            ))}</tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};



interface ChartSectionProps {
    title: string;
    rawData: DataRow[];
}

const ChartSection: React.FC<ChartSectionProps> = ({ title, rawData }) => {
  // 1. Transform rawData (applies fillMonths and unification of employee names)
  const data: DataRow[] = useMemo(() => transformChartData(rawData), [rawData]);

  // 2. Extract unique unified employee names from the transformed data
  const names: string[] = useMemo(() => Array.from(
    // Flatten all keys from all data rows, filter out 'name', make unique
    new Set(data.flatMap(d => Object.keys(d)).filter(k => k !== "name"))
  ), [data]);

  // 3. Generate styles based on the unified names
  const styles: StyleMap = useMemo(() => makeStyles(names), [names]);

  // Check if there's any actual data to plot after transformation
  const hasPlottableData: boolean = useMemo(() =>
    data.some(row => names.some(nameKey => row[nameKey] != null && row[nameKey] !== "")),
  [data, names]);


  // Don't render chart or table if no plottable data exists
  if (!hasPlottableData) {
     return (
        <section className="chart-section flex flex-col pt-8">
            <h2 className="text-lg font-semibold mb-3">{title}</h2>
            <p className="text-gray-500">No data available to display for this section.</p>
        </section>
     );
  }

  // (Removed unused yMax and its useMemo hook)

  return (
    <section className="chart-section flex flex-col pt-8">
      {/* Title comes from processedBlocks (e.g., "Block Name #2") */}
      <h2 className="text-lg font-semibold mb-3">{title}</h2>

      <ResponsiveContainer width="100%" height={260}>
        <LineChart data={data} margin={{ top: 5, right: 30, left: 5, bottom: 45 }}> {/* Adjusted margins */}
          <CartesianGrid strokeDasharray="3 3" stroke="#ccc" /> {/* Lighter grid */}
          <XAxis
            dataKey="name"
            interval={0}
            angle={-45} // Angle labels for better fit
            textAnchor="end"
            height={60} // Increased height for angled labels
            tick={{ fontSize: 10, fill: '#666' }} // Smaller font, gray color
            />
          <YAxis
            domain={[0, 120]} // Use dynamic max
            tickFormatter={(value) => `${round(value)}`} // Apply rounding to YAxis ticks
            allowDecimals={false} // Ensure integer ticks if possible
            tick={{ fontSize: 10, fill: '#666' }}
            />
          <Tooltip content={<CustomTooltip />} />
          {/* Map over unified names to create lines */}
          {names.map(unifiedName => {
            const style = styles[unifiedName] ?? { color: '#000000', dash: '0' }; // Fallback style
            return (
                <Line
                key={unifiedName} // Key is now the unified name
                dataKey={unifiedName} // dataKey matches the unified name in `data`
                stroke={style.color}
                strokeDasharray={style.dash}
                strokeWidth={2} // Slightly thinner lines
                dot={{ r: 3, fill: style.color, strokeWidth: 1, stroke: '#fff' }} // Add white stroke to dots
                activeDot={{ r: 5, strokeWidth: 1, stroke: '#fff' }} // Slightly larger active dot
                isAnimationActive={false} // Disable animation for print/consistency
                connectNulls // Connect lines across null data points
                />
            );
          })}
        </LineChart>
      </ResponsiveContainer>

      {/* Pass transformed data to the StatsTable */}
      <StatsTable rows={data} />
    </section>
  );
};

/* ----------------------------------------------------------------- page */
export default function TimeBlockComparisonPage() {
  // useParams returns string | string[] | undefined. Ensure it's a single string.
  const params = useParams();
  const rawId = params?.id;
  const companyId: string = typeof rawId === 'string' ? rawId : '';

  const [blocks, setBlocks] = useState<IBlock[] | null>(null);
  const [err, setErr] = useState<string | null>(null);

  // Process blocks to add unique display names for duplicate BLOCK names
  const processedBlocks: IBlock[] = useMemo(() => {
    if (!blocks) return [];
    const nameTracker: Record<string, number> = {}; // Tracks counts of each blockName
    return blocks.map((block) => {
      const count = nameTracker[block.blockName] = (nameTracker[block.blockName] || 0) + 1;
      const displayName = count > 1 ? `${block.blockName} #${count}` : block.blockName;
      return { ...block, displayName }; // Add displayName to block object
    });
  }, [blocks]); // Recalculate only when blocks data changes

  useEffect(() => {
    if (!companyId) {
        setErr("Report ID is missing in the URL.");
        setBlocks(null); // Clear any previous data
        return;
    };

    let isMounted = true; // Flag to prevent state update on unmounted component
    setBlocks(null); // Reset blocks on companyId change
    setErr(null);    // Reset error on companyId change

    axios.get<ApiResponse>(`https://api.panoramamas.com/api/standard-reports/${companyId}`)
      .then(res => {
        if (!isMounted) return; // Don't update state if component unmounted
        // Validate response data structure
        if (res.data && Array.isArray(res.data.ReportData)) {
           // Further validation: ensure data within blocks is array of objects
           const isValid = res.data.ReportData.every(block =>
                block && typeof block === 'object' && Array.isArray(block.data) &&
                block.data.every(row => typeof row === 'object' && row !== null) &&
                (!block.subblocks || (Array.isArray(block.subblocks) && block.subblocks.every(sub => sub && typeof sub === 'object' && Array.isArray(sub.data))))
           );
           if (isValid) {
               setBlocks(res.data.ReportData);
           } else {
               console.error("Invalid data structure within API response:", res.data);
               setErr("Received invalid data structure within the API response.");
           }
        } else {
           console.error("Invalid API response structure:", res.data);
           setErr("Received invalid data format from API.");
        }
      })
      .catch((e: AxiosError) => {
        if (!isMounted) return;
        console.error("API Error:", e);
        // Provide more specific error messages
        if (e.response) {
            setErr(`API Error: ${e.response.status} - ${e.response.statusText}`);
        } else if (e.request) {
            setErr("API Error: No response received from server.");
        } else {
            setErr(`API Error: ${e.message}`);
        }
      });

      // Cleanup function to set isMounted to false when component unmounts
      return () => {
          isMounted = false;
      };
  }, [companyId]); // Re-run effect when companyId changes

  // --- Render logic ---
  if (!companyId && !err) return <div className="p-8 text-xl text-red-600">‚ùó Missing report ID</div>; // Show missing ID if not already errored
  if (err) return <div className="p-8 text-xl text-red-600">Error loading report: {err}</div>;
  // Use `blocks === null` for loading state, `processedBlocks.length === 0` for no data AFTER loading
  if (blocks === null) return <div className="p-8 text-xl">Loading report data‚Ä¶</div>;
  if (processedBlocks.length === 0) return <div className="p-8 text-xl">No report data found for this ID.</div>;


  const today: string = new Date().toLocaleDateString();

  return (
    <>
      {/* ------------------------------------------------ header / action */}
      <header className="report-header flex justify-between items-center bg-gray-100 border-b border-gray-300 px-6 py-3 text-sm print:fixed print:top-0 print:left-0 print:right-0 print:z-50 print:bg-white">
      <img
              src="/logo.png"
              width={130}
              height={50}
            />          <div className="text-right">
          <h1 className="font-semibold m-0 leading-tight">Time Horizon Report</h1>
          <p className="m-0">ID: <strong>{companyId}</strong></p>
          <p className="m-0">Date: {today}</p>
        </div>
      </header>

      <button
        className="print:hidden fixed bottom-4 right-4 z-[60] rounded bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
        onClick={() => window.print()}
        aria-label="Download or Print Report"
      >
        üñ®Ô∏è Download / Print
      </button>

      {/* ------------------------------------------------ body */}
      {/* Iterate over processedBlocks which have the unique displayName */}
      <main className="report-container mx-auto max-w-[860px] pt-20 pb-16 print:pt-[85px] print:pb-[40px]"> {/* Adjusted print padding-top */}
        {processedBlocks.map((block, idx) => (
          // Key uses original name + index for stability
          <Fragment key={`${block.blockName}-${idx}`}>
            <div className="pdf-page">
               {/* ChartSection uses the block's displayName for its title
                   and the block's raw data, which it will transform internally */}
              <ChartSection
                 title={block.displayName ?? block.blockName} // Use displayName, fallback to original
                 rawData={block.data}
               />
            </div>

            {/* Render sub-blocks if they exist */}
            {block.subblocks?.map((sub, subIdx) => (
              <div key={`${block.blockName}-${idx}-sub-${sub.subblockName}-${subIdx}`} className="pdf-page">
                {/* Create title for sub-block section */}
                <ChartSection
                    title={`${block.displayName ?? block.blockName} ‚Äì ${sub.subblockName}`}
                    rawData={sub.data}
                 />
              </div>
            ))}
          </Fragment>
        ))}
      </main>

      {/* ------------------------------------------------ footer */}
      <footer className="report-footer flex justify-between items-center bg-gray-100 border-t border-gray-300 px-6 py-3 text-xs print:fixed print:bottom-0 print:left-0 print:right-0 print:bg-white">
        <p className="m-0">¬© {new Date().getFullYear()} Panorama Management Advisory Services</p>
        <span>Confidential & Proprietary</span>
      </footer>

      {/* ------------------------------------------------ styles */}
      <style jsx global>{`
        body {
          margin: 0;
          font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; /* Modern font stack */
          -webkit-print-color-adjust: exact;
           print-color-adjust: exact;
           background-color: #f9fafb; /* Light gray background for non-print */
        }

        @media screen {
            .report-container { /* Add some padding for screen view */
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }


        .pdf-page {
          margin-bottom: 3rem;
          padding-top: 1rem; /* Reduced top padding within page */
           /* Ensure content doesn't break across pages */
           break-inside: avoid;
           page-break-inside: avoid;
           background-color: #fff; /* White background for content sections */
           padding: 1.5rem; /* Add padding inside the page */
           border-radius: 8px; /* Rounded corners for screen view */
           box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Subtle shadow for screen */
           print:shadow-none print:rounded-none print:border-none print:p-0; /* Reset for print */
        }

        @media print {
           body {
               background-color: #fff; /* Ensure white background for print */
           }
           .report-header {
             position: fixed; top: 0; left: 0; right: 0; z-index: 50;
             background-color: white !important;
             border-bottom: 1px solid #ccc;
           }
           .report-footer {
             position: fixed; bottom: 0; left: 0; right: 0; z-index: 50;
             background-color: white !important;
             border-top: 1px solid #ccc;
           }
           .report-container {
             /* --- Increased padding-top to prevent overlap with fixed header --- */
             /* --- Adjusted padding-bottom slightly for footer clearance --- */
             padding-bottom: 40px !important;
             max-width: none !important;
             margin: 0 auto !important;
             width: 100%;
             padding-left: 0 !important; /* Remove screen padding */
             padding-right: 0 !important;
           }
           .pdf-page {
              padding-top: 85px !important;         
              margin-bottom: 1.5rem;
              box-shadow: none; /* Remove shadow for print */
              border-radius: 0; /* Remove rounding for print */
              padding: 0; /* Remove padding for print */
              background-color: transparent; /* Inherit background */
              /* Page break handling */
              break-before: page;
              page-break-before: always;
           }
           .pdf-page:first-of-type {
             break-before: auto;
             page-break-before: auto;
           }
           /* Hide print button */
           button.print\:hidden { display: none; }

           @page {
             size: A4 portrait;
             margin: 15mm 12mm 15mm 12mm; /* Slightly adjust margins */
           }

           /* Improve table printing */
            table { width: 100% !important; page-break-inside: auto; } /* Allow table to break */
            th, td { border: 1px solid #bbb !important; font-size: 9pt !important; padding: 4px !important;}
            thead { display: table-header-group; } /* Repeat headers */
            tr { page-break-inside: avoid; page-break-after: auto; }
        }

        .chart-section {
          min-height: 300px; /* Ensure enough space for chart + table */
          display: flex;
          flex-direction: column;
        }
        .recharts-responsive-container {
           flex-grow: 1;
        }
        /* Style for angled X-axis labels */
        .recharts-cartesian-axis-tick-value tspan {
            /* font-size is handled by tick={{}} prop */
        }

      `}</style>
    </>
  );
}